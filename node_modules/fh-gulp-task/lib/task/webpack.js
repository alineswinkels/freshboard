'use strict';

var _ = require('lodash'),
    config = require('../config'),
    fs = require('fs'),
    gutil = require('gulp-util'),
    glob = require('glob'),
    path = require('path'),
    webpack = require('webpack'),
    ExtractTextPlugin = require('extract-text-webpack-plugin'),
    StatsWriterPlugin = require('webpack-stats-plugin').StatsWriterPlugin;

var aliases = null;

var getAliases = function() {
    if (!_.isNull(aliases)) {
        return aliases;
    }

    aliases = {
        web: process.cwd() + '/web'
    };

    _.forEach(glob.sync('@(vendor|src)/**/*@(B|b)undle/Resources/public/assets/src'), function(dir) {
        var bundle = path.basename(glob.sync(dir.replace('Resources/public/assets/src', '*Bundle.php'))[0], '.php');
        aliases[bundle.toLowerCase().replace(/bundle$/, '')] = process.cwd() + '/' + dir;
    });

    return aliases;
};

var createWebpackOptions = function(options) {
    var name = options.appName;

    var newOptions = _.merge({
        output: {
            path: path.resolve(process.cwd(), 'web/assets/' + name + '/build'),
            publicPath: options.publicPath || '/assets/' + name + '/build/',
            filename: '[name].js',
            chunkFilename: '[name].[hash].[id].js'
        },
        resolveLoader: {
            root: [path.resolve(__dirname, '../../node_modules')]
        }
    }, options.webpack || {});

    var resolveEntryPaths = function(entry) {
        return _.isArray(entry) ? _.map(entry, resolveEntryPaths) : path.resolve(options.basePath, entry);
    };

    _.merge(newOptions, {
        entry: _.mapValues(options.entries, resolveEntryPaths),
        resolve: {
            alias: getAliases()
        },
        module: {
            loaders: [
                {
                    test: /\.scss$/,
                    loader: ExtractTextPlugin.extract(
                        'style',
                        'raw!autoprefixer!sass?' + JSON.stringify(options.sass)
                    )
                },
                {
                    test: /\.css$/,
                    loader: ExtractTextPlugin.extract('style', 'raw')
                }
                
            ]
        },
        plugins: [
            new ExtractTextPlugin('[name].css')
        ]
    }, function(a, b) {
        if (_.isArray(a)) {
            return a.concat(b);
        }
    });

    if (options.js && options.js.uglify) {
        newOptions.plugins.push(
            new webpack.optimize.UglifyJsPlugin({
                sourceMap: false,
                compress: { warnings: false }
            })
        );
    }

    newOptions.plugins.push(
        new StatsWriterPlugin(_.defaults(
            {},
            options.stats || {},
            {
                path: newOptions.output.path,
                fields: ['hash', 'assetsByChunkName']
            })
        )
    );

    return newOptions;
};

var build = function(app, watch) {
    var compiler = webpack(createWebpackOptions(app));

    var reportStatus = function(err, stats) {
        if (err) {
            throw new gutil.PluginError('webpack', err);
        }

        gutil.log('[webpack]', stats.toString({}));
    };

    if (watch) {
        compiler.watch(200, reportStatus);
    } else {
        compiler.run(reportStatus);
    }
};

module.exports.build = function() {
    _.forIn(config.apps, function(config, key) {
        config.appName = key;
        build(config);
    });
};

module.exports.watch = function() {
    _.forIn(config.apps, function(config, key) {
        config.appName = key;
        build(config, true);
    });
};
